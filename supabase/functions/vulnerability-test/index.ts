
import "https://deno.land/x/xhr@0.1.0/mod.ts";
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface VulnerabilityTestResult {
  type: 'sql_injection' | 'xss' | 'security_headers';
  vulnerable: boolean;
  description: string;
  severity: 'high' | 'medium' | 'low' | 'safe';
  details: {
    testPerformed: string;
    payload?: string;
    requestDetails: {
      method: string;
      endpoint: string;
      headers: string;
      timestamp: string;
    };
    responseDetails: {
      statusCode: string;
      headers: string;
      responseTime: string;
      bodyPreview?: string;
    };
    recommendation: string;
    owaspReference: string;
    riskLevel: string;
  };
}

async function testSecurityHeaders(url: string): Promise<VulnerabilityTestResult> {
  const startTime = Date.now();
  
  try {
    console.log(`Testando headers de segurança para: ${url}`);
    
    const response = await fetch(url, {
      method: 'HEAD',
      headers: {
        'User-Agent': 'Security-Scanner/1.0',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
      },
    });

    const responseTime = Date.now() - startTime;
    const headers: Record<string, string> = {};
    response.headers.forEach((value, key) => {
      headers[key.toLowerCase()] = value;
    });

    // Verifica headers de segurança críticos
    const securityIssues = [];
    let severityLevel: 'high' | 'medium' | 'low' | 'safe' = 'safe';

    if (!headers['strict-transport-security']) {
      securityIssues.push('HSTS não configurado');
      severityLevel = 'high';
    }

    if (!headers['content-security-policy']) {
      securityIssues.push('Content Security Policy ausente');
      severityLevel = 'high';
    }

    if (!headers['x-frame-options']) {
      securityIssues.push('X-Frame-Options não configurado');
      if (severityLevel === 'safe') severityLevel = 'medium';
    }

    if (!headers['x-content-type-options']) {
      securityIssues.push('X-Content-Type-Options ausente');
      if (severityLevel === 'safe') severityLevel = 'medium';
    }

    const isVulnerable = securityIssues.length > 0;

    return {
      type: 'security_headers',
      vulnerable: isVulnerable,
      description: `Teste de headers de segurança - ${securityIssues.length} problemas encontrados`,
      severity: severityLevel,
      details: {
        testPerformed: `Análise dos headers de segurança HTTP. Problemas encontrados: ${securityIssues.join(', ')}`,
        requestDetails: {
          method: 'HEAD',
          endpoint: url,
          headers: `User-Agent: Security-Scanner/1.0\nAccept: text/html,application/xhtml+xml`,
          timestamp: new Date().toISOString(),
        },
        responseDetails: {
          statusCode: `${response.status} ${response.statusText}`,
          headers: Object.entries(headers).map(([k, v]) => `${k}: ${v}`).join('\n'),
          responseTime: `${responseTime}ms`,
        },
        recommendation: isVulnerable ? 
          `VULNERABILIDADES DE SEGURANÇA DETECTADAS:\n${securityIssues.map(issue => `• ${issue}`).join('\n')}\n\nAções recomendadas:\n1. Configurar Strict-Transport-Security para HTTPS\n2. Implementar Content Security Policy restritivo\n3. Adicionar X-Frame-Options: DENY\n4. Configurar X-Content-Type-Options: nosniff\n5. Implementar X-XSS-Protection: 1; mode=block` :
          'Headers de segurança configurados adequadamente. Continue monitorando.',
        owaspReference: 'OWASP Top 10 2021 - A05: Security Misconfiguration',
        riskLevel: isVulnerable ? (severityLevel === 'high' ? 'CRÍTICO' : 'MÉDIO') : 'BAIXO'
      }
    };

  } catch (error) {
    console.error('Erro no teste de headers:', error);
    return {
      type: 'security_headers',
      vulnerable: true,
      description: 'Erro ao testar headers de segurança',
      severity: 'high',
      details: {
        testPerformed: `Falha na conexão: ${error.message}`,
        requestDetails: {
          method: 'HEAD',
          endpoint: url,
          headers: 'N/A',
          timestamp: new Date().toISOString(),
        },
        responseDetails: {
          statusCode: 'Connection Failed',
          headers: 'N/A',
          responseTime: `${Date.now() - startTime}ms`,
        },
        recommendation: 'Verificar se o site está acessível e configurado corretamente.',
        owaspReference: 'Connection Error',
        riskLevel: 'DESCONHECIDO'
      }
    };
  }
}

async function testBasicXSS(url: string): Promise<VulnerabilityTestResult> {
  const startTime = Date.now();
  
  try {
    console.log(`Testando XSS básico para: ${url}`);
    
    // Payload XSS simples para teste
    const xssPayload = '<script>alert("XSS-Test")</script>';
    const testUrl = `${url}?q=${encodeURIComponent(xssPayload)}`;
    
    const response = await fetch(testUrl, {
      method: 'GET',
      headers: {
        'User-Agent': 'Security-Scanner/1.0 (XSS Test)',
        'Accept': 'text/html,application/xhtml+xml',
      },
    });

    const responseTime = Date.now() - startTime;
    const responseText = await response.text();
    const first200Chars = responseText.substring(0, 200);

    // Verifica se o payload aparece sem escape na resposta
    const isVulnerable = responseText.includes('<script>alert("XSS-Test")</script>');

    return {
      type: 'xss',
      vulnerable: isVulnerable,
      description: `Teste básico de XSS - ${isVulnerable ? 'VULNERÁVEL' : 'Protegido'}`,
      severity: isVulnerable ? 'medium' : 'safe',
      details: {
        testPerformed: 'Teste de XSS refletido usando payload básico em parâmetro de URL',
        payload: xssPayload,
        requestDetails: {
          method: 'GET',
          endpoint: testUrl,
          headers: 'User-Agent: Security-Scanner/1.0 (XSS Test)',
          timestamp: new Date().toISOString(),
        },
        responseDetails: {
          statusCode: `${response.status} ${response.statusText}`,
          headers: 'Content-Type: ' + (response.headers.get('content-type') || 'unknown'),
          responseTime: `${responseTime}ms`,
          bodyPreview: first200Chars + (responseText.length > 200 ? '...' : ''),
        },
        recommendation: isVulnerable ?
          'VULNERABILIDADE XSS DETECTADA:\n1. Implementar escape/encoding de todos os outputs\n2. Usar Content Security Policy restritivo\n3. Validar e sanitizar todos os inputs\n4. Implementar X-XSS-Protection header' :
          'Proteção XSS adequada detectada. Continue validando inputs e outputs.',
        owaspReference: 'OWASP Top 10 2021 - A03: Injection (XSS)',
        riskLevel: isVulnerable ? 'ALTO' : 'BAIXO'
      }
    };

  } catch (error) {
    console.error('Erro no teste XSS:', error);
    return {
      type: 'xss',
      vulnerable: false,
      description: 'Erro ao testar XSS',
      severity: 'safe',
      details: {
        testPerformed: `Falha no teste XSS: ${error.message}`,
        requestDetails: {
          method: 'GET',
          endpoint: url,
          headers: 'N/A',
          timestamp: new Date().toISOString(),
        },
        responseDetails: {
          statusCode: 'Connection Failed',
          headers: 'N/A',
          responseTime: `${Date.now() - startTime}ms`,
        },
        recommendation: 'Verificar conectividade com o site.',
        owaspReference: 'Test Error',
        riskLevel: 'DESCONHECIDO'
      }
    };
  }
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { url, testType } = await req.json();
    
    if (!url) {
      return new Response(
        JSON.stringify({ error: 'URL é obrigatória' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    console.log(`Iniciando teste de vulnerabilidade: ${testType} para ${url}`);
    
    let result: VulnerabilityTestResult;
    
    switch (testType) {
      case 'xss':
        result = await testBasicXSS(url);
        break;
      case 'security_headers':
      default:
        result = await testSecurityHeaders(url);
        break;
    }

    return new Response(
      JSON.stringify({
        url,
        testType,
        timestamp: new Date().toISOString(),
        result,
        success: true,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      }
    );

  } catch (error) {
    console.error('Erro na edge function de vulnerabilidade:', error);
    return new Response(
      JSON.stringify({ error: error.message, success: false }),
      {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      }
    );
  }
});
