
import { useState } from 'react';
import { VulnerabilityTestService } from '@/services/vulnerabilityTestService';

interface VulnerabilityResult {
  type: 'sql_injection' | 'xss' | 'rfi' | 'security_headers';
  vulnerable: boolean;
  description: string;
  severity: 'high' | 'medium' | 'low' | 'safe';
  details: {
    testPerformed: string;
    payload?: string;
    requestDetails: {
      method: string;
      endpoint: string;
      headers: string;
      timestamp: string;
    };
    responseDetails: {
      statusCode: string;
      headers: string;
      body?: string;
      responseTime: string;
      bodyPreview?: string;
    };
    recommendation: string;
    owaspReference: string;
    riskLevel: string;
  };
}

interface ServerInfo {
  server: string;
  platform: string;
  version: string;
  xPoweredBy: string | null;
  remoteAddress: string;
  protocol: string;
  cipher: string;
  responseTime: number;
  headers: Record<string, string>;
}

export const useVulnerabilityTester = (url: string) => {
  const [isLoading, setIsLoading] = useState(false);
  const [results, setResults] = useState<VulnerabilityResult[]>([]);
  const [hasRun, setHasRun] = useState(false);
  const [expandedResult, setExpandedResult] = useState<number | null>(null);
  const [serverInfo, setServerInfo] = useState<ServerInfo | null>(null);
  const [discoveredEndpoints, setDiscoveredEndpoints] = useState<string[]>([]);

  const runVulnerabilityTests = async () => {
    setIsLoading(true);
    setHasRun(true);
    
    console.log(`Iniciando varredura OWASP Top 10 para: ${url}`);
    
    try {
      // Descobre endpoints reais do site
      const { EndpointDiscovery } = await import('@/services/endpointDiscovery');
      const endpoints = await EndpointDiscovery.discoverEndpoints(url);
      const targetEndpoints = EndpointDiscovery.selectTargetEndpoints(endpoints);
      setDiscoveredEndpoints(targetEndpoints.map(ep => `${ep.path} (${ep.type})`));
      
      console.log('Endpoints descobertos para teste:', targetEndpoints);
      
      // Obtém informações reais do servidor
      const serverDetails = await VulnerabilityTestService.generateServerInfo(url);
      setServerInfo(serverDetails);
      console.log('Informações reais do servidor obtidas:', serverDetails);
      
      // Simula tempo de teste mais realista
      await new Promise(resolve => setTimeout(resolve, 4000));
      
      // Executa todos os testes OWASP Top 10
      const sqlInjectionTest = await VulnerabilityTestService.performSQLInjectionTest(url, serverDetails);
      const xssTest = await VulnerabilityTestService.performXSSTest(url, serverDetails);
      const rfiTest = await VulnerabilityTestService.performRFITest(url, serverDetails);
      const securityHeadersTest = await VulnerabilityTestService.performSecurityHeadersTest(url, serverDetails);
      
      const testResults: VulnerabilityResult[] = [
        sqlInjectionTest, 
        xssTest, 
        rfiTest, 
        securityHeadersTest
      ];
      
      setResults(testResults);
      console.log('Varredura OWASP Top 10 concluída:', testResults);
    } catch (error) {
      console.error('Erro na varredura OWASP:', error);
      // Em caso de erro, mostra resultados de fallback
      const fallbackResults: VulnerabilityResult[] = [
        {
          type: 'security_headers',
          vulnerable: true,
          description: 'Erro ao conectar com o servidor',
          severity: 'high',
          details: {
            testPerformed: 'Falha na conexão',
            requestDetails: {
              method: 'HEAD',
              endpoint: url,
              headers: 'N/A',
              timestamp: new Date().toISOString(),
            },
            responseDetails: {
              statusCode: 'Connection Failed',
              headers: 'N/A',
              responseTime: '0ms',
            },
            recommendation: 'Verificar se o site está acessível.',
            owaspReference: 'Connection Error',
            riskLevel: 'DESCONHECIDO'
          }
        }
      ];
      setResults(fallbackResults);
    } finally {
      setIsLoading(false);
    }
  };

  const toggleExpandedResult = (index: number) => {
    setExpandedResult(expandedResult === index ? null : index);
  };

  return {
    isLoading,
    results,
    hasRun,
    expandedResult,
    serverInfo,
    discoveredEndpoints,
    runVulnerabilityTests,
    toggleExpandedResult
  };
};

export type { VulnerabilityResult, ServerInfo };
